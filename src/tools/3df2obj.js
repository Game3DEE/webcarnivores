const fs = require('fs');
const path = require('path');

const { PNG } = require('pngjs');
const KaitaiStream = require('kaitai-struct/KaitaiStream');

const C3DF = require('../kaitai/C3df');

function exportTexture(texData, texName, width, height) {
    const png = new PNG({
        width,
        height,
    });

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const i = y * width + x;
            const pixel = texData[i*2+1] << 8 | texData[i*2];
            let r = ((pixel >> 10) & 0x1f) << 3;
            let g = ((pixel >>  5) & 0x1f) << 3;
            let b = ((pixel >>  0) & 0x1f) << 3;

            png.data[i*4+0] = r;
            png.data[i*4+1] = g;
            png.data[i*4+2] = b;
            png.data[i*4+3] = 0xff;
        }
    }
    fs.writeFileSync(texName, PNG.sync.write(png));
}

const basename = path.basename(process.argv[2].toLowerCase(), '.3df');

const model = new C3DF(new KaitaiStream(fs.readFileSync(process.argv[2])));

let s = `# Generated by 3df2obj.js\nmtllib ${basename}.mtl\nusemtl mat\n`;
const v = model.vertices;
let vIdx = 1;
model.faces.forEach(f => {
    s += `v ${v[f.v1].x} ${v[f.v1].y} ${v[f.v1].z}\n`
    s += `v ${v[f.v2].x} ${v[f.v2].y} ${v[f.v2].z}\n`
    s += `v ${v[f.v3].x} ${v[f.v3].y} ${v[f.v3].z}\n`
    s += `vt ${f.tax / 256} ${f.tay / 256}\n`
    s += `vt ${f.tbx / 256} ${f.tby / 256}\n`
    s += `vt ${f.tcx / 256} ${f.tcy / 256}\n`
    s += `f ${vIdx}/${vIdx} ${vIdx+1}/${vIdx+1} ${vIdx+2}/${vIdx+2}\n`
    vIdx += 3;
})
fs.writeFileSync(`${basename}.obj`, s);
s = `# Generated by 3df2obj.js\nnewmtl mat\n\tmap_Ka ${basename}.png\n`;
fs.writeFileSync(`${basename}.mtl`, s);

exportTexture(model.textureData, `${basename}.png`, model.textureWidth, model.textureHeight);
