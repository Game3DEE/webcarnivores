const fs = require('fs');
const path = require('path');

const { PNG } = require('pngjs');
const KaitaiStream = require('kaitai-struct/KaitaiStream');

const C3DF = require('../kaitai/C3df');

function exportTexture(texData, texName, width, height) {
    const png = new PNG({
        width,
        height,
    });

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const i = y * width + x;
            const pixel = texData[i*2+1] << 8 | texData[i*2];
            let r = ((pixel >> 10) & 0x1f) << 3;
            let g = ((pixel >>  5) & 0x1f) << 3;
            let b = ((pixel >>  0) & 0x1f) << 3;

            png.data[i*4+0] = r;
            png.data[i*4+1] = g;
            png.data[i*4+2] = b;
            png.data[i*4+3] = 0xff;
        }
    }
    fs.writeFileSync(texName, PNG.sync.write(png));
}

const basename = path.basename(process.argv[2].toLowerCase(), '.3df');

const model = new C3DF(new KaitaiStream(fs.readFileSync(process.argv[2])));

let s = `# Generated by 3df2obj.js\nmtllib ${basename}.mtl\nusemtl mat\n`;
const v = model.vertices;

model.vertices.forEach(v => {
    s += `v ${v.x.toFixed(6)} ${v.z.toFixed(6)} ${v.y.toFixed(6)}\n`
})

model.faces.forEach(f => {
    s += `vt ${(f.tax / 256).toFixed(6)} ${(f.tay / 256).toFixed(6)} 0.0\n`
    s += `vt ${(f.tbx / 256).toFixed(6)} ${(f.tby / 256).toFixed(6)} 0.0\n`
    s += `vt ${(f.tcx / 256).toFixed(6)} ${(f.tcy / 256).toFixed(6)} 0.0\n`
});

let vIdx = 1;
model.faces.forEach(f => {
    s += `f ${f.v1+1}/${vIdx} ${f.v2+1}/${vIdx+1} ${f.v3+1}/${vIdx+2}\n`
    vIdx += 3;
})

fs.writeFileSync(`${basename}.obj`, s);
s = `# Generated by 3df2obj.js\nnewmtl mat\n\tmap_Ka ${basename}.png\n`;
fs.writeFileSync(`${basename}.mtl`, s);

exportTexture(model.textureData, `${basename}.png`, model.textureWidth, model.textureHeight);
